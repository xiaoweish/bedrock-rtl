[{"name":"Simultaneous Read and Write with Bypass Enabled","description":"Cover that: wr_valid is 1, rd_addr_valid is 1, wr_addr equals rd_addr.","category":"misc","type":"cover","metadata":{},"id":"c5ca2d95-88fc-4158-95e2-da198b469445","thought":null},{"name":"Sequential Write Request","description":"Assume that If: wr_valid is 0, then: wr_valid eventually becomes 1.","category":"misc","type":"assumption","metadata":{},"id":"bbcd988c-0c78-4e21-b04a-07867326ef94","thought":null},{"name":"Sequential Read Request","description":"Assume that If: rd_addr_valid is 0, then: rd_addr_valid eventually becomes 1.","category":"misc","type":"assumption","metadata":{},"id":"b268d7c9-5eff-413e-85f4-123b99e4d492","thought":null},{"name":"Valid Write Address","description":"Assume that If: wr_valid is 1, then: wr_addr is within the valid address range.","category":"misc","type":"assumption","metadata":{},"id":"538ae426-8467-4336-ad18-97d6348dc57e","thought":null},{"name":"Valid Read Address","description":"Assume that If: rd_addr_valid is 1, then: rd_addr is within the valid address range.","category":"misc","type":"assumption","metadata":{},"id":"fef1f069-ea02-44da-83b3-3d252fc58c06","thought":null},{"name":"Valid Write Data","description":"Assume that If: wr_valid is 1, then: wr_data is not unknown.","category":"misc","type":"assumption","metadata":{},"id":"ea734c32-6836-4101-a8b9-cdf2533858e3","thought":null},{"name":"Valid Read Address Usage","description":"Assume that If: rd_addr_valid is 1, then: rd_addr is not unknown.","category":"misc","type":"assumption","metadata":{},"id":"32a9fdf5-2cca-4e13-adea-e0631d5ab014","thought":null},{"name":"Unified Reset Scenario","description":"The single SVA property should verify that when 'rst' transitions from '1' to '0', 'rd_data_valid' is reset to '0' on the same clock cycle.","category":"reset","type":"assertion","metadata":{"isReset":true},"id":"51dfebab-f0eb-406e-ae70-373b0d45e728","thought":null},{"name":"Write Interface Verification","description":"This VIP checks the handshake mechanism for the write interface, verifying the valid and data signals: wr_valid, wr_addr, wr_data.","category":"misc","type":"vip","metadata":{"vip":"valid_ready_protocol","properties":[{"name":"valid_stays_high","description":"When valid is high and ready is low, valid must remain high"},{"name":"data_stable_when_valid_not_ready","description":"Data must be stable when valid is high and ready is low"},{"name":"valid_accepted_by_ready","description":"Ensure that valid will eventually be accepted by ready"},{"name":"valid_known","description":"Ensure valid signal always has known values"},{"name":"ready_known","description":"Ensure ready signal always has known values"}]},"id":"e0598acd-94e7-404c-8fe8-f834b778cd8e","thought":null},{"name":"Read Interface Verification","description":"This VIP checks the handshake mechanism for the read interface, verifying the valid and data signals: rd_addr_valid, rd_addr, rd_data_valid, rd_data.","category":"misc","type":"vip","metadata":{"vip":"valid_ready_protocol","properties":[{"name":"valid_stays_high","description":"When valid is high and ready is low, valid must remain high"},{"name":"data_stable_when_valid_not_ready","description":"Data must be stable when valid is high and ready is low"},{"name":"valid_accepted_by_ready","description":"Ensure that valid will eventually be accepted by ready"},{"name":"valid_known","description":"Ensure valid signal always has known values"},{"name":"ready_known","description":"Ensure ready signal always has known values"}]},"id":"3e1c383f-eaa8-415d-9c2c-99404ecafb88","thought":null},{"name":"Data Integrity Verification","description":"This VIP verifies data integrity during read operations, ensuring that the data read matches expected values: rd_data_valid, rd_data.","category":"misc","type":"vip","metadata":{"vip":"jasper_scoreboard_3","properties":[{"name":"data_integrity","description":"Asserts data integrity between incoming_data and outgoing_data"},{"name":"no_overflow","description":"Asserts that the number of chunks stored by jasper_scoreboard_3 does not surpass MAX_PENDING."},{"name":"lite_check_always_zero","description":"Lite data integrity checks"},{"name":"lite_check_always_one","description":"Lite data integrity checks"},{"name":"lite_check_always_symbol","description":"Lite data integrity checks"},{"name":"lite_check_never_symbol","description":"Lite data integrity checks"},{"name":"lite_check_one_symbol_only","description":"Lite data integrity checks"},{"name":"lite_check_data_count","description":"Lite data integrity checks"},{"name":"FIRST[i].first_integrity","description":"Data integrity checks for first FIRST_CHECKS_COUNT chunks that enter DUV"},{"name":"COVER[i].data_in","description":"Covers for first COVER_COUNT chunks that enter the DUV"},{"name":"COVER[i].data_out","description":"Covers for first COVER_COUNT chunks that exit the DUV"},{"name":"cfg_first_check","description":"Parameter check: Ensure that PA is not configured as out-of-order mode and FIRST_CHECKS_COUNT is greater than zero"},{"name":"cfg_latency_check","description":"Parameter check: Ensure LATENCY has a legal value"}]},"id":"c779dad2-9a60-4dda-a7c4-fda5b76bfa6c","thought":null},{"name":"No Operation Check","description":"Check that if 'rd_addr_valid = 0', then 'rd_data_valid' is 0 after 'ReadDataDepthStages + ReadDataWidthStages' clock cycles.","category":"basicFunctionality","type":"assertion","metadata":{},"id":"4ccc6de8-e1ed-4e89-957c-1c946f929ae0","thought":null},{"name":"Write Operation Check","description":"Check that if 'wr_valid = 1' then the data at 'wr_addr' is updated with 'wr_data' eventually.","category":"basicFunctionality","type":"assertion","metadata":{},"id":"31c27864-9d62-4f5c-8747-b7962ee01fa3","thought":null},{"name":"Read Operation Check","description":"Check that 'rd_addr_valid = 1', then 'rd_data_valid' is asserted and 'rd_data' reflects the data at 'rd_addr' after the delay determined by 'ReadDataDepthStages' and 'ReadDataWidthStages'.","category":"basicFunctionality","type":"assertion","metadata":{},"id":"65301e4a-24e5-46aa-bc6a-e98095fe61d3","thought":null},{"name":"Simultaneous Read and Write Operation Check","description":"Check that if 'wr_valid = 1', 'rd_addr_valid = 1', and 'wr_addr != rd_addr', then after a delay of 'ReadDataDepthStages + ReadDataWidthStages', 'rd_data' reflects the data stored in memory at 'rd_addr'.","category":"basicFunctionality","type":"assertion","metadata":{},"id":"f1b5883e-91ba-425f-8911-74781bcae7ba","thought":null},{"name":"Memory Reset Check","description":"Check that if 'EnableMemReset = 1' and 'rst = 1', then 'rd_data' is 0 eventually.","category":"basicFunctionality","type":"assertion","metadata":{},"id":"399a6ee3-d559-4441-bbbf-daa71551f5d2","thought":null},{"name":"Output Validity Check","description":"Check that if 'rd_addr_valid = 1', then 'rd_data_valid' is asserted after the delay determined by 'ReadDataDepthStages' and 'ReadDataWidthStages'.","category":"basicFunctionality","type":"assertion","metadata":{},"id":"4095ccb9-68e2-4914-a2c7-cc857ddd0d5e","thought":null},{"name":"Sequential Write and Read Consistency","description":"Check that if wr_valid is 1 and followed one or more cycles later by rd_addr_valid being 1 for the same address, then rd_data_valid is eventually 1 and rd_data matches wr_data.","category":"endToEnd","type":"assertion","metadata":{},"id":"8c963c93-4c77-4274-94be-fb8f6398ad0e","thought":null},{"name":"Memory Initialization Verification","description":"Check that if EnableMemReset is 1, upon reset, rd_data is 0 when rd_addr_valid is 1 for any address before any write operation occurs.","category":"endToEnd","type":"assertion","metadata":{},"id":"a1a4480d-3980-4011-80e8-38b7fabc578c","thought":null},{"name":"Zero-Cycle Read-After-Write Hazard with Bypass Enabled","description":"When TileEnableBypass is 1, check that if wr_valid and rd_addr_valid are both high on the same clock cycle, and wr_addr equals rd_addr, then when the corresponding rd_data_valid is asserted, rd_data equals the original wr_data from read latency cycles ago.","category":"cornerCase","type":"assertion","metadata":{},"id":"db35cde4-e747-4441-9078-71a92e113f5c","thought":null},{"name":"One-Cycle Read-After-Write Hazard with Bypass Disabled","description":"When TileEnableBypass is 0, check that if wr_valid and rd_addr_valid are both high on the same clock cycle, and wr_addr equals rd_addr, then when the corresponding rd_data_valid is asserted, rd_data equals the stored memory value rather than the new wr_data from read latency cycles ago.","category":"cornerCase","type":"assertion","metadata":{},"id":"963effa1-5473-47b3-b43c-2f721b3da7ae","thought":null},{"name":"Simultaneous Read and Write Operation Check","description":"Check that when both 'wr_valid' and 'rd_addr_valid' are high, the RAM can perform simultaneous read and write operations on the same clock cycle.","category":"errorScenarios","type":"assertion","metadata":{},"id":"f1ea318a-6d89-471c-811c-49a2f7fd84d9","thought":null}]
