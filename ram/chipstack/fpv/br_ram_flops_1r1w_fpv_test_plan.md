
/*
*********************************************
**    File auto-generated by Chipstack.    **
*********************************************
*/

## Formal Unit Test Scenarios
### File: ./ram/rtl/br_ram_flops_1r1w.sv

|Name|Description|
|---|---|
|Simultaneous Read and Write with Bypass Enabled|Cover that: wr_valid is 1, rd_addr_valid is 1, wr_addr equals rd_addr.|
|Sequential Write Request|Assume that If: wr_valid is 0, then: wr_valid eventually becomes 1.|
|Sequential Read Request|Assume that If: rd_addr_valid is 0, then: rd_addr_valid eventually becomes 1.|
|Valid Write Address|Assume that If: wr_valid is 1, then: wr_addr is within the valid address range.|
|Valid Read Address|Assume that If: rd_addr_valid is 1, then: rd_addr is within the valid address range.|
|Valid Write Data|Assume that If: wr_valid is 1, then: wr_data is not unknown.|
|Valid Read Address Usage|Assume that If: rd_addr_valid is 1, then: rd_addr is not unknown.|
|Unified Reset Scenario|The single SVA property should verify that when 'rst' transitions from '1' to '0', 'rd_data_valid' is reset to '0' on the same clock cycle.|
|Write Interface Verification|This VIP checks the handshake mechanism for the write interface, verifying the valid and data signals: wr_valid, wr_addr, wr_data.|
|Read Interface Verification|This VIP checks the handshake mechanism for the read interface, verifying the valid and data signals: rd_addr_valid, rd_addr, rd_data_valid, rd_data.|
|Data Integrity Verification|This VIP verifies data integrity during read operations, ensuring that the data read matches expected values: rd_data_valid, rd_data.|
|No Operation Check|Check that if 'rd_addr_valid = 0', then 'rd_data_valid' is 0 after 'ReadDataDepthStages + ReadDataWidthStages' clock cycles.|
|Write Operation Check|Check that if 'wr_valid = 1' then the data at 'wr_addr' is updated with 'wr_data' eventually.|
|Read Operation Check|Check that 'rd_addr_valid = 1', then 'rd_data_valid' is asserted and 'rd_data' reflects the data at 'rd_addr' after the delay determined by 'ReadDataDepthStages' and 'ReadDataWidthStages'.|
|Simultaneous Read and Write Operation Check|Check that if 'wr_valid = 1', 'rd_addr_valid = 1', and 'wr_addr != rd_addr', then after a delay of 'ReadDataDepthStages + ReadDataWidthStages', 'rd_data' reflects the data stored in memory at 'rd_addr'.|
|Memory Reset Check|Check that if 'EnableMemReset = 1' and 'rst = 1', then 'rd_data' is 0 eventually.|
|Output Validity Check|Check that if 'rd_addr_valid = 1', then 'rd_data_valid' is asserted after the delay determined by 'ReadDataDepthStages' and 'ReadDataWidthStages'.|
|Sequential Write and Read Consistency|Check that if wr_valid is 1 and followed one or more cycles later by rd_addr_valid being 1 for the same address, then rd_data_valid is eventually 1 and rd_data matches wr_data.|
|Memory Initialization Verification|Check that if EnableMemReset is 1, upon reset, rd_data is 0 when rd_addr_valid is 1 for any address before any write operation occurs.|
|Zero-Cycle Read-After-Write Hazard with Bypass Enabled|When TileEnableBypass is 1, check that if wr_valid and rd_addr_valid are both high on the same clock cycle, and wr_addr equals rd_addr, then when the corresponding rd_data_valid is asserted, rd_data equals the original wr_data from read latency cycles ago.|
|One-Cycle Read-After-Write Hazard with Bypass Disabled|When TileEnableBypass is 0, check that if wr_valid and rd_addr_valid are both high on the same clock cycle, and wr_addr equals rd_addr, then when the corresponding rd_data_valid is asserted, rd_data equals the stored memory value rather than the new wr_data from read latency cycles ago.|
|Simultaneous Read and Write Operation Check|Check that when both 'wr_valid' and 'rd_addr_valid' are high, the RAM can perform simultaneous read and write operations on the same clock cycle.|
