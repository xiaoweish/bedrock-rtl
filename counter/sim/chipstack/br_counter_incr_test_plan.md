
/*
*********************************************
**    File auto-generated by Chipstack.    **
*********************************************
*/

## Simulation Unit Test Scenarios
### File: ./counter/rtl/br_counter_incr.sv

|Name|Description|
|---|---|
|ReinitializeCounter|Given the counter is in any state, when the `reinit` signal is asserted high with a specific `initial_value`, then the counter should reset to `initial_value` in the next clock cycle, regardless of the current counter state.|
|IncrementCounter|Given the counter is in any state, when the `incr_valid` signal is asserted high with a specific `incr` value, then the counter should increment by `incr` in the next clock cycle, wrapping around if necessary.|
|HoldCounterValue|Given the counter is in any state, when both `reinit` and `incr_valid` signals are low, then the counter should hold its current value in the next clock cycle.|
|ReinitializeAndIncrement|Given the counter is in any state, when both `reinit` and `incr_valid` signals are asserted high with specific `initial_value` and `incr`, then the counter should reset to `initial_value` and increment by `incr` in the next clock cycle.|
|IncrementWithZero|Given the counter is in any state, when the `incr_valid` signal is high and `incr` is set to 0, then the counter should hold its current value in the next clock cycle.|
|ReinitializeWithMaxValue|Given the counter is in any state, when the `reinit` signal is asserted high with `initial_value` equal to `MaxValue`, then the counter should reset to `MaxValue` in the next clock cycle.|
|IncrementBeyondMaxValue|Given the counter is at `MaxValue`, when the `incr_valid` signal is high with a non-zero `incr`, then the counter should wrap around to zero and continue incrementing in the next clock cycle.|
|SequentialIncrementAndReinitialize|Given the counter is in any state, when the `incr_valid` signal is asserted high with a specific `incr` value for 3 cycles followed by asserting `reinit` high with a specific `initial_value`, then the counter should increment by `incr` for 3 cycles and reset to `initial_value` in the next cycle, repeating this sequence.|
|ContinuousIncrementWithConditionalReinitialize|Given the counter is in any state, when the `incr_valid` signal is asserted high with a specific `incr` value continuously and a condition is met to assert `reinit` high with a specific `initial_value`, then the counter should increment by `incr` continuously and reset to `initial_value` when the condition is met, allowing dynamic control of the counter's state.|
|IncrementCausesOverflow|Given the counter is near `MaxValue`, when the `incr_valid` signal is high with an `incr` value that causes the counter to exceed `MaxValue`, then the counter should wrap around to zero and continue incrementing in the next clock cycle.|
|IncrementWithMaxIncrement|Given the counter is in any state, when the `incr_valid` signal is high with `incr` set to `MaxIncrement`, then the counter should increment by `MaxIncrement` in the next clock cycle, wrapping around if necessary.|
|ReinitializeWithIncrementCausingOverflow|Given the counter is in any state, when both `reinit` and `incr_valid` signals are asserted high with `initial_value` and an `incr` value that causes overflow, then the counter should reset to `initial_value` and wrap around after adding `incr` in the next clock cycle.|
|ReinitializeWithZeroIncrement|Given the counter is in any state, when both `reinit` and `incr_valid` signals are asserted high with `initial_value` and `incr` set to 0, then the counter should reset to `initial_value` and hold its value in the next clock cycle.|
|IncrementToMaxValue|Given the counter is just below `MaxValue`, when the `incr_valid` signal is high with an `incr` value that exactly reaches `MaxValue`, then the counter should set `value_next` to `MaxValue` in the next clock cycle.|
|ReinitializeToZero|Given the counter is in any state, when the `reinit` signal is asserted high with `initial_value` set to 0, then the counter should reset to 0 in the next clock cycle.|
|IncrementWithReinitAtBoundary|Given the counter is at `MaxValue`, when both `reinit` and `incr_valid` signals are asserted high with `initial_value` and `incr` that cause the counter to wrap around, then the counter should reset to `initial_value` and wrap around after adding `incr` in the next clock cycle.|
|IncrementExceedsMaxIncrement|Given the counter is in any state, when the `incr_valid` signal is asserted high and `incr` exceeds `MaxIncrement`, then an assertion should trigger indicating the error, but the counter should continue its operation without any automatic response.|
|InitialValueExceedsMaxValue|Given the counter is in any state, when the `reinit` signal is asserted high with `initial_value` exceeding `MaxValue`, then an assertion should trigger indicating the error, but the counter should continue its operation without any automatic response.|
|IncrementAndInitialValueExceedLimits|Given the counter is in any state, when both `reinit` and `incr_valid` signals are asserted high with `initial_value` exceeding `MaxValue` and `incr` exceeding `MaxIncrement`, then assertions should trigger for both errors, but the counter should continue its operation without any automatic response.|
